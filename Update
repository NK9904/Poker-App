```plaintext name=README.md
# Poker AI Cloud Application

A scalable, serverless poker AI application deployed on AWS, featuring real-time player analysis, probability optimization, and a React-based frontend.

## Features
- Real-time player profiling and pattern recognition
- Dynamic exploitation strategy adjustment
- Advanced probability calculations with real-time adjustments
- Confidence-based decision making
- WebSocket-based real-time monitoring
- Scalable serverless architecture on AWS

## Project Structure
- `frontend/`: React frontend with Tailwind CSS
- `backend/`: Node.js/Express backend with AWS Lambda handlers
- `src/`: Core AI logic
- `infrastructure/`: AWS CDK infrastructure code
- `types/`: Shared TypeScript types
- `package.json`: Project dependencies
- `serverless.yml`: Serverless framework configuration

## Prerequisites
- Node.js 18+
- AWS CLI configured with appropriate credentials
- Serverless Framework (`npm install -g serverless`)
- AWS CDK (`npm install -g aws-cdk`)

## Setup Instructions
1. Clone the repository
2. Install dependencies: `npm install`
3. Deploy infrastructure: `cd infrastructure && cdk deploy`
4. Deploy backend: `serverless deploy --stage prod`
5. Build and deploy frontend: `cd frontend && npm run build && aws s3 sync build/ s3://<bucket-name>`
6. Update frontend `App.tsx` with API Gateway and WebSocket endpoints from deployment outputs

## Usage
- Access the frontend via the CloudFront URL or locally at `http://localhost:3000`
- Input game state (hand, players, pot size) to receive AI-driven decisions
- Monitor real-time updates via WebSocket connection

## Environment Variables
- `CONNECTIONS_TABLE`: DynamoDB table name for WebSocket connections
- `WEBSOCKET_ENDPOINT`: WebSocket API endpoint
- `AWS_REGION`: AWS region (e.g., us-east-1)

## Development
- Run frontend locally: `cd frontend && npm start`
- Test backend locally: `serverless invoke local --function decision`

## Notes
- Replace `<your-api-gateway-endpoint>` and `<your-websocket-endpoint>` in `frontend/src/App.tsx` with actual endpoints
- Ensure TensorFlow.js is configured for GPU support if needed
- Monitor AWS Lambda logs for debugging
```

```typescript name=types/index.ts
export interface GameState {
  currentHand: string;
  players: string[];
  potSize: number;
}

export interface Action {
  type: 'fold' | 'call' | 'raise' | 'check';
  amount: number;
}

export interface PlayerProfile {
  id: string;
  getFeatures: () => any;
  getRecentActions: (limit: number) => any[];
  getTendencies: () => any;
  setExploitablePatterns: (patterns: any) => void;
  getFoldFrequency: (pressure: any) => number;
  getBluffFrequency: () => number;
  getCallFrequency: () => number;
  getRaiseFrequency: () => number;
  getRecentPatterns: (limit: number) => any[];
}

export interface ProbabilityResult {
  rawEquity: number;
  adjustedEquity: number;
  confidenceInterval: number[];
  exploitationOpportunities: any[];
}

export interface OptimizedDecision {
  action: Action;
  confidence: number;
  expectedValue: number;
}

export interface GameMetrics {
  winRate: number;
  exploitationSuccess: number;
  profitability: number;
  decisionAccuracy: number;
}
```

```typescript name=frontend/src/App.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { w3cwebsocket } from 'websocket';
import { GameState, Action } from '../../types';
import './index.css';

const App: React.FC = () => {
  const [gameState, setGameState] = useState<Partial<GameState>>({});
  const [action, setAction] = useState<Action | null>(null);
  const [ws, setWs] = useState<w3cwebsocket | null>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const websocket = new w3cwebsocket('wss://<your-websocket-endpoint>');
    setWs(websocket);

    websocket.onopen = () => console.log('WebSocket connected');
    websocket.onerror = () => setError('WebSocket connection failed');
    websocket.onmessage = (message) => {
      try {
        const data = JSON.parse(message.data.toString());
        if (data.action) setAction(data.action);
      } catch (err) {
        setError('Failed to parse WebSocket message');
      }
    };

    return () => websocket.close();
  }, []);

  const handleGameStateSubmit = useCallback(async () => {
    if (!gameState.currentHand || !gameState.players || !gameState.potSize) {
      setError('Please fill in all game state fields');
      return;
    }

    try {
      const response = await fetch('https://<your-api-gateway-endpoint>/decision', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(gameState),
      });

      if (!response.ok) throw new Error('API request failed');
      const result = await response.json();
      setAction(result.action);
      setError(null);
    } catch (err) {
      setError('Failed to fetch AI decision');
    }
  }, [gameState]);

  return (
    <div className="container mx-auto p-4">
      <h1 className="text-3xl font-bold mb-4">Poker AI</h1>
      {error && <p className="text-red-500 mb-4">{error}</p>}
      <div className="mb-4">
        <h2 className="text-xl font-semibold">Submit Game State</h2>
        <input
          type="text"
          placeholder="Current Hand (e.g., AsKd)"
          value={gameState.currentHand || ''}
          onChange={(e) => setGameState({ ...gameState, currentHand: e.target.value })}
          className="border p-2 mr-2 rounded"
        />
        <input
          type="text"
          placeholder="Players (comma-separated)"
          value={gameState.players?.join(',') || ''}
          onChange={(e) => setGameState({ ...gameState, players: e.target.value.split(',').map(s => s.trim()) })}
          className="border p-2 mr-2 rounded"
        />
        <input
          type="number"
          placeholder="Pot Size"
          value={gameState.potSize || ''}
          onChange={(e) => setGameState({ ...gameState, potSize: parseInt(e.target.value) || 0 })}
          className="border p-2 mr-2 rounded"
        />
        <button
          onClick={handleGameStateSubmit}
          className="bg-blue-500 text-white p-2 rounded hover:bg-blue-600"
        >
          Get Decision
        </button>
      </div>
      {action && (
        <div>
          <h2 className="text-xl font-semibold">AI Decision</h2>
          <p>Action: {action.type}</p>
          <p>Amount: {action.amount}</p>
        </div>
      )}
    </div>
  );
};

export default App;
```

```css name=frontend/src/index.css
@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  font-family: 'Inter', sans-serif;
}
```

```json name=frontend/package.json
{
  "name": "poker-ai-frontend",
  "version": "1.0.0",
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "websocket": "^1.0.34",
    "tailwindcss": "^3.4.1"
  },
  "devDependencies": {
    "react-scripts": "^5.0.1",
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "@types/websocket": "^1.0.5"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "eject": "react-scripts eject"
  }
}
```

```typescript name=backend/src/handlers/decision.ts
import { APIGatewayProxyHandler } from 'aws-lambda';
import { PokerAI } from '../../src/ai/PokerAI';
import { GameState, Action } from '../../../types';

export const handler: APIGatewayProxyHandler = async (event) => {
  try {
    if (!event.body) {
      return {
        statusCode: 400,
        body: JSON.stringify({ error: 'Missing game state' }),
      };
    }

    const gameState: GameState = JSON.parse(event.body);
    if (!gameState.currentHand || !gameState.players || !gameState.potSize) {
      return {
        statusCode: 400,
        body: JSON.stringify({ error: 'Invalid game state' }),
      };
    }

    const pokerAI = new PokerAI({
      realTimeTracking: true,
      exploitationOptimization: true,
      confidenceThreshold: 0.85,
    });

    const action: Action = await pokerAI.makeDecision(gameState);

    return {
      statusCode: 200,
      body: JSON.stringify({ action }),
    };
  } catch (error) {
    console.error('Decision handler error:', error);
    return {
      statusCode: 500,
      body: JSON.stringify({ error: 'Internal server error' }),
    };
  }
};
```

```typescript name=backend/src/handlers/websocket.ts
import { APIGatewayProxyHandler } from 'aws-lambda';
import { DynamoDB } from 'aws-sdk';
import { RealTimeMonitor } from '../../src/monitoring/RealTimeMonitor';
import { GameState } from '../../../types';

const dynamoDb = new DynamoDB.DocumentClient();
const monitor = new RealTimeMonitor();

export const connect: APIGatewayProxyHandler = async (event) => {
  try {
    const connectionId = event.requestContext.connectionId;
    if (!connectionId) {
      return { statusCode: 400, body: JSON.stringify({ error: 'Missing connection ID' }) };
    }

    await dynamoDb
      .put({
        TableName: process.env.CONNECTIONS_TABLE!,
        Item: { connectionId },
      })
      .promise();

    return { statusCode: 200, body: JSON.stringify({ message: 'Connected' }) };
  } catch (error) {
    console.error('WebSocket connect error:', error);
    return { statusCode: 500, body: JSON.stringify({ error: 'Internal server error' }) };
  }
};

export const disconnect: APIGatewayProxyHandler = async (event) => {
  try {
    const connectionId = event.requestContext.connectionId;
    if (!connectionId) {
      return { statusCode: 400, body: JSON.stringify({ error: 'Missing connection ID' }) };
    }

    await dynamoDb
      .delete({
        TableName: process.env.CONNECTIONS_TABLE!,
        Key: { connectionId },
      })
      .promise();

    return { statusCode: 200, body: JSON.stringify({ message: 'Disconnected' }) };
  } catch (error) {
    console.error('WebSocket disconnect error:', error);
    return { statusCode: 500, body: JSON.stringify({ error: 'Internal server error' }) };
  }
};

export const monitor: APIGatewayProxyHandler = async (event) => {
  try {
    const gameState: GameState = JSON.parse(event.body || '{}');
    await monitor.monitorAndAdjust(gameState);

    const connections = await dynamoDb
      .scan({
        TableName: process.env.CONNECTIONS_TABLE!,
      })
      .promise();

    const apiGateway = new AWS.ApiGatewayManagementApi({
      endpoint: process.env.WEBSOCKET_ENDPOINT!,
    });

    const sendPromises = (connections.Items || []).map(async (connection) => {
      try {
        await apiGateway
          .postToConnection({
            ConnectionId: connection.connectionId,
            Data: JSON.stringify({ action: 'monitor-update', metrics: await monitor.getMetrics() }),
          })
          .promise();
      } catch (error) {
        console.error(`Failed to send to connection ${connection.connectionId}:`, error);
        await dynamoDb
          .delete({
            TableName: process.env.CONNECTIONS_TABLE!,
            Key: { connectionId: connection.connectionId },
          })
          .promise();
      }
    });

    await Promise.all(sendPromises);

    return { statusCode: 200, body: JSON.stringify({ message: 'Monitoring update sent' }) };
  } catch (error) {
    console.error('WebSocket monitor error:', error);
    return { statusCode: 500, body: JSON.stringify({ error: 'Internal server error' }) };
  }
};
```

```yaml name=serverless.yml
service: poker-ai-backend

provider:
  name: aws
  runtime: nodejs18.x
  region: us-east-1
  environment:
    CONNECTIONS_TABLE: PokerAIConnections
    WEBSOCKET_ENDPOINT: ${opt:stage, self:provider.stage}-websocket.execute-api.${self:provider.region}.amazonaws.com
    AWS_NODEJS_CONNECTION_REUSE_ENABLED: '1'
  iam:
    role:
      statements:
        - Effect: Allow
          Action:
            - dynamodb:PutItem
            - dynamodb:DeleteItem
            - dynamodb:Scan
          Resource: arn:aws:dynamodb:${self:provider.region}:*:table/PokerAIConnections
        - Effect: Allow
          Action:
            - execute-api:ManageConnections
          Resource: arn:aws:execute-api:${self:provider.region}:*:*

functions:
  decision:
    handler: backend/src/handlers/decision.handler
    events:
      - http:
          path: /decision
          method: post
          cors: true
  connect:
    handler: backend/src/handlers/websocket.connect
    events:
      - websocket:
          route: $connect
  disconnect:
    handler: backend/src/handlers/websocket.disconnect
    events:
      - websocket:
          route: $disconnect
  monitor:
    handler: backend/src/handlers/websocket.monitor
    events:
      - websocket:
          route: monitor

resources:
  Resources:
    ConnectionsTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: PokerAIConnections
        AttributeDefinitions:
          - AttributeName: connectionId
            AttributeType: S
        KeySchema:
          - AttributeName: connectionId
            KeyType: HASH
        BillingMode: PAY_PER_REQUEST
```

```typescript name=infrastructure/lib/poker-ai-stack.ts
import * as cdk from 'aws-cdk-lib';
import * as s3 from 'aws-cdk-lib/aws-s3';
import * as cloudfront from 'aws-cdk-lib/aws-cloudfront';
import * as origins from 'aws-cdk-lib/aws-cloudfront-origins';

export class PokerAIStack extends cdk.Stack {
  constructor(scope: cdk.App, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    const bucket = new s3.Bucket(this, 'PokerAIFrontendBucket', {
      websiteIndexDocument: 'index.html',
      publicReadAccess: true,
      removalPolicy: cdk.RemovalPolicy.DESTROY,
      autoDeleteObjects: true,
    });

    new cloudfront.Distribution(this, 'PokerAIDistribution', {
      defaultBehavior: {
        origin: new origins.S3Origin(bucket),
        viewerProtocolPolicy: cloudfront.ViewerProtocolPolicy.REDIRECT_TO_HTTPS,
      },
      errorResponses: [
        {
          httpStatus: 403,
          responseHttpStatus: 200,
          responsePagePath: '/index.html',
        },
        {
          httpStatus: 404,
          responseHttpStatus: 200,
          responsePagePath: '/index.html',
        },
      ],
    });

    new cdk.CfnOutput(this, 'BucketName', {
      value: bucket.bucketName,
      description: 'S3 bucket name for frontend hosting',
    });
  }
}
```

```json name=package.json
{
  "name": "poker-ai-app",
  "version": "1.0.0",
  "dependencies": {
    "aws-sdk": "^2.1440.0",
    "aws-cdk-lib": "^2.100.0",
    "express": "^4.18.2",
    "@tensorflow/tfjs-node-gpu": "^4.1.0",
    "rxjs": "^7.8.0"
  },
  "devDependencies": {
    "@types/node": "^18.11.9",
    "@types/express": "^4.17.17",
    "typescript": "^5.0.4",
    "serverless": "^3.38.0",
    "serverless-offline": "^13.3.3"
  },
  "scripts": {
    "cdk": "cdk",
    "deploy": "serverless deploy --stage prod",
    "build-frontend": "cd frontend && npm run build",
    "test": "jest"
  }
}
```

```typescript name=src/ai/PokerAI.ts
import { RealTimeOptimizer } from './optimization/RealTimeOptimizer';
import { PlayerProfiler } from './profiling/PlayerProfiler';
import { EnhancedProbabilityEngine } from './probability/EnhancedProbabilityEngine';
import { GameState, Action, OptimizedDecision } from '../../types';

interface PokerAIConfig {
  realTimeTracking: boolean;
  exploitationOptimization: boolean;
  confidenceThreshold: number;
}

export class PokerAI {
  private readonly optimizer: RealTimeOptimizer;
  private readonly profiler: PlayerProfiler;
  private readonly probabilityEngine: EnhancedProbabilityEngine;

  constructor(config: PokerAIConfig) {
    this.optimizer = new RealTimeOptimizer();
    this.profiler = new PlayerProfiler();
    this.probabilityEngine = new EnhancedProbabilityEngine();
  }

  async makeDecision(gameState: GameState): Promise<Action> {
    try {
      const opponents = await this.profiler.getActiveProfiles(gameState.players);
      const probability = await this.probabilityEngine.calculateWinProbability(
        gameState.currentHand,
        opponents,
        gameState
      );
      const optimizedDecision: OptimizedDecision = await this.optimizer.optimizeDecision(
        gameState,
        opponents
      );
      await this.logDecision(optimizedDecision, gameState);
      return optimizedDecision.action;
    } catch (error) {
      console.error('PokerAI decision error:', error);
      throw new Error('Failed to generate decision');
    }
  }

  private async logDecision(decision: OptimizedDecision, gameState: GameState): Promise<void> {
    // Implement logging logic (e.g., to DynamoDB or CloudWatch)
    console.log('Decision logged:', { decision, gameState });
  }
}
```

```typescript name=src/monitoring/RealTimeMonitor.ts
import { GameState, GameMetrics } from '../../types';

interface MetricsCollector {
  collect: () => Promise<GameMetrics>;
}

interface AdjustmentEngine {
  adjust: (metrics: GameMetrics) => Promise<void>;
}

export class RealTimeMonitor {
  private readonly metrics: MetricsCollector;
  private readonly adjustmentEngine: AdjustmentEngine;

  constructor() {
    this.metrics = { collect: this.collectMetrics.bind(this) };
    this.adjustmentEngine = { adjust: this.applyAdjustments.bind(this) };
  }

  async monitorAndAdjust(gameState: GameState): Promise<void> {
    try {
      const currentMetrics = await this.metrics.collect();
      await this.adjustmentEngine.adjust(currentMetrics);
      await this.logAdjustments(currentMetrics);
    } catch (error) {
      console.error('Monitoring error:', error);
      throw new Error('Failed to monitor and adjust');
    }
  }

  async getMetrics(): Promise<GameMetrics> {
    return this.collectMetrics();
  }

  private async collectMetrics(): Promise<GameMetrics> {
    return {
      winRate: await this.calculateWinRate(),
      exploitationSuccess: await this.measureExploitationSuccess(),
      profitability: await this.calculateProfitability(),
      decisionAccuracy: await this.measureDecisionAccuracy(),
    };
  }

  private async calculateWinRate(): Promise<number> {
    // Placeholder: Implement actual win rate calculation
    return 0.75;
}

  private async measureExploitationSuccess(): Promise<number> {
    // Placeholder: Implement actual exploitation success measurement
    return 0.82;
  }

  private async calculateProfitability(): Promise<number> {
    // Placeholder: Implement actual profitability calculation
    return 1000;
  }

  private async measureDecisionAccuracy(): Promise<number> {
    // Placeholder: Implement actual decision accuracy measurement
    return 0.9;
  }

  private async applyAdjustments(metrics: GameMetrics): Promise<void> {
    // Placeholder: Implement adjustment logic
    console.log('Applying adjustments:', metrics);
  }

  private async logAdjustments(metrics: GameMetrics): Promise<void> {
    // Placeholder: Implement logging (e.g., to CloudWatch)
    console.log('Adjustments logged:', metrics);
  }
}
```
